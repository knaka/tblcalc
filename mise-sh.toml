# Add this file and shell script directory with wildcard to `includes` directive array.
# 
#   [task_config]
#   includes = [
#     "mise-tasks",
#     "mise-sh.toml",
#     "mise-sh/*.toml",
#   ]

["task-sh:install"]
description = '[<name>...] Install task-sh files. If no name is specified, lists available files.'
tools = {"jq" = "1.8", "gh" = "2"}
run = '''
#!/usr/bin/env sh -o nounset -o errexit

tasks_dir="$MISE_PROJECT_ROOT"/"${MISE_SH_TASKS_DIR-./mise-sh/}"

temp_dir="$(mktemp -d)"
# shellcheck disable=SC2064
trap "rm -fr '$temp_dir'" EXIT

verbose=true

# Guard against multiple calls. $1 is a unique ID
first_call() {
  eval "\${called_$1-false}" && return 1
  eval "called_$1=true"
}

github_prepare_token() {
  first_call b1929c9 || return 0
  if test "${GITHUB_TOKEN+set}" = set
  then
    echo "Using existing \$GITHUB_TOKEN environment variable." >&2
    return 0
  fi
  if command -v gh >/dev/null
  then
    if gh auth status >/dev/null
    then
      echo "Using GitHub token gh(1) provides." >&2
      GITHUB_TOKEN="$(gh auth token)"
      return 0
    fi
  fi
  echo "Accessing GitHub API with anonymous access." >&2
}

github_api_request() {
  local url="$1"
  github_prepare_token
  set -- \
    --silent \
    --header "X-GitHub-Api-Version: 2022-11-28" \
    --header "Accept: application/vnd.github+json" \
    --fail
  if test "${GITHUB_TOKEN+set}" = set
  then
    set -- "$@" --header "Authorization: Bearer $GITHUB_TOKEN"
  fi
  "$verbose" && echo "Accessing GitHub API: $url" >&2
  curl "$@" "$url"
}

github_tree_get() {
  local owner=
  local repos=
  local tree_sha=main
  OPTIND=1; while getopts _-: OPT
  do
    test "$OPT" = - && OPT="${OPTARG%%=*}" && OPTARG="${OPTARG#"$OPT"=}"
    case "$OPT" in
      (owner) owner="$OPTARG";;
      (repos) repos="$OPTARG";;
      (branch|tag|tree|tree-sha) tree_sha="$OPTARG";;
      (*) echo "Unexpected option: $OPT" >&2; exit 1;;
    esac
  done
  shift $((OPTIND-1))

  # REST API endpoints for Git trees - GitHub Docs https://docs.github.com/en/rest/git/trees
  local url
  url="$(printf "https://api.github.com/repos/%s/%s/git/trees/%s" "$owner" "$repos" "$tree_sha")"
  github_api_request "$url"
}

# Fetch raw content of a file from a GitHub repository
# Usage: github_raw_fetch [OPTIONS]
# Options:
#   --owner=OWNER         GitHub repository owner/organization
#   --repos=REPOS         GitHub repository name
#   --tree-sha=SHA        Tree SHA, branch name, or tag name (default: main). Aliases: --branch, --tag, --tree
#   --path=PATH           Path to the file within the repository
github_raw_fetch() {
  local owner=
  local repos=
  local tree_sha=main
  local path=
  OPTIND=1; while getopts _-: OPT
  do
    test "$OPT" = - && OPT="${OPTARG%%=*}" && OPTARG="${OPTARG#"$OPT"=}"
    case "$OPT" in
      (owner) owner="$OPTARG";;
      (repos) repos="$OPTARG";;
      (branch|tag|tree|tree-sha) tree_sha="$OPTARG";;
      (path) path="$OPTARG";;
      (*) echo "Unexpected option: $OPT" >&2; exit 1;;
    esac
  done
  shift $((OPTIND-1))

  path="${path#/}"
  local url
  url="$(printf "https://raw.githubusercontent.com/%s/%s/%s/%s" "$owner" "$repos" "$tree_sha" "$path")"
  curl --fail --silent "$url"
}

state_path="$MISE_PROJECT_ROOT/.task-sh-state.json"

# [<name>...] Install task-sh files. If no name is specified, lists available files.
install() {
  local force=false
  if test "$#" -gt 0 && test "$1" = "--force"
  then
    shift
    force=true
  fi
  local rc=0
  local resp
  local main_branch=main
  resp="$(github_tree_get --owner="knaka" --repos="task-sh")"
  local latest_commit; latest_commit="$(printf "%s" "$resp" | jq -r .sha)"
  "$verbose" && echo "Latest commit of \"$main_branch\" is \"$latest_commit\"." >&2
  if test $# = 0
  then
    echo "Available files:" >&2
    echo "$resp" \
    | jq -r '.tree[] | .path' \
    | grep -e '^[^._].*\.lib\.sh$' \
    | sed -e 's/^/  /'
    return
  fi
  if ! test -r "$state_path"
  then
    echo '{}' >"$state_path"
  fi
  local file
  local name
  for file in "$@"
  do
    name="${file##*/}"
    "$verbose" && echo "Name: \"$name\"."
    local indent="  "
    local node mode last_sha
    local last_sha=
    last_sha="$(jq -r --arg name "$name" '.last_sha[$name] // ""' "$state_path")"
    "$verbose" && echo "${indent}Last installed SHA:" "$last_sha"
    local local_sha=
    if test -r "$file"
    then
      local_sha="$(git hash-object "$file")"
    fi
    "$verbose" && echo "${indent}Local SHA:" "$local_sha"
    if test -n "$last_sha" -a -n "$local_sha" -a "$last_sha" != "$local_sha"
    then
      echo "\"$name\" is modified locally." >&2
      rc=1
      continue
    fi
    if test "$file" = "$name"
    then
      case "$file" in
        (*/*) ;;
        (*) file="$tasks_dir"/"$name"
      esac
    fi
    node="$(echo "$resp" | jq -c --arg name "$name" '.tree[] | select(.path == $name)')"
    if test -z "$node"
    then
      echo "\"$name\" does not exist in the remote repository."
      rc=1
      continue
    fi
    local new_sha
    new_sha="$(echo "$node" | jq -r .sha)"
    "$verbose" && echo "${indent}Remote SHA:" "$new_sha" >&2
    if ! "$force" && test -n "$local_sha" -a "$new_sha" = "$last_sha"
    then
      echo "\"$name\" is up to date. Skipping." >&2
      continue
    fi
    # shellcheck disable=SC2059
    printf "Downloading \"$name\" ... " >&2
    if test "$name" = "task.sh"
    then
      "$verbose" && echo "Lazily replacing \"$file.new\" with \"$file\"." >&2
      chaintrap "mv \"$file.new\" \"$file\"" EXIT
      local file="$file.new"
    fi
    github_raw_fetch --owner="knaka" --repos="task-sh" --tree-sha="$latest_commit" --path=/"$name" >"$file"
    echo "done." >&2
    local temp_json="$temp_dir"/1caef61.json
    jq --arg name "$name" --arg sha "$new_sha" '.last_sha[$name] = $sha' "$state_path" >"$temp_json"
    cat "$temp_json" >"$state_path"
    mode="$(echo "$node" | jq -r .mode)"
    "$verbose" && echo "  Mode:" "$mode"
    chmod "${mode#???}" "$file"
  done
  return "$rc"
}

install "$@"
'''

["task-sh:update"]
description = "Update task-sh files."
run = '''
#!/usr/bin/env sh -o nounset -o errexit

tasks_dir="$MISE_PROJECT_ROOT"/mise-sh

update() {
  local file
  local excludes=":"
  for file in "$tasks_dir"/project*.lib.sh "$tasks_dir"/prj*.lib.sh
  do
    test -e "$file" || continue
    excludes="$excludes:$file:"
  done
  set --
  for file in "$tasks_dir"/*.lib.sh "$tasks_dir"/task.sh
  do
    test -r "$file" || continue
    case "$excludes" in
      (*:$file:*) continue;;
    esac
    set -- "$@" "$file"
  done
  mise run task-sh:install \
    "$MISE_PROJECT_ROOT"/mise \
    "$MISE_PROJECT_ROOT"/mise.cmd \
    "$MISE_PROJECT_ROOT"/mise-sh.toml \
    "$@"
}

update "$@"
'''

["task-sh:gen"]
description = "Generate task-sh interface tasks."
usage = '''
flag "--sh-tasks-dir <dir>" {
  help "Shell tasks directory path"
  default "./mise-sh/"
  env "MISE_SH_TASKS_DIR"
}
'''
tools = {"jq" = "1.8", "yj" = "5"}
run = '''
#!/usr/bin/env sh -o nounset -o errexit

mise_sh_tasks_dir="$usage_sh_tasks_dir"

# Parse shell task files and extract task/subcmd information with their metadata.
# Outputs lines in format: "<type> <name> <func_name> <basename> <body>"
extract_task_info() {
  awk -f - "$@" <<'EOF'
BEGIN {
  desc = ""
  mise_hdrs_count = 0
}
/^#MISE / || /^# *\[MISE\] / {
  line = $0
  gsub(/^#MISE +/, "", line)
  gsub(/^# *\[MISE\] +/, "", line)
  mise_hdrs[mise_hdrs_count++] = line
  next
}
/^#/ {
  if (desc == "") {
    line = $0
    gsub(/^#+[ ]*/, "", line)
    desc = line
  }
  next
}
/^(task_|subcmd_)[[:alnum:]_]()/ {
  func_name = $1
  sub(/\(\).*$/, "", func_name)
  type = func_name
  sub(/_.*$/, "", type)
  name = func_name
  sub(/^[^_]+_/, "", name)
  gsub(/__/, ":", name)
  base = FILENAME
  sub(/^.*\//, "", base)
  print type " " name " " func_name " " base " " desc
  for (i = 0; i < mise_hdrs_count; i++) {
    type = "mise"
    print type " " name " " func_name " " base " " mise_hdrs[i]
  }
  desc = ""
  delete mise_hdrs
  mise_hdrs_count = 0
  next
}
{
  desc = ""
  delete mise_hdrs
  mise_hdrs_count = 0
}
END {
  print "nop - - - -"
}
EOF
}

# Generate the shell script that will be executed when a Mise task is invoked.
# The script changes to the mise-sh directory, sources the library file,
# then returns to the original directory and calls the task function.
gen_script() {
  cat <<EOF
#!/usr/bin/env sh

set -- "\$PWD" "\$@"
cd "\$MISE_PROJECT_ROOT"/"$mise_sh_tasks_dir"
. "$base"
cd "\$1"
shift
"$1" "\$@"
EOF
}

# Read task info from stdin and generate TOML files for each source file.
# Groups tasks by their source basename and outputs gen-<basename>.toml files.
# Handles "task"/"subcmd" types by setting description and run script,
# and "mise" type by merging additional mise configuration headers.
generate_task_tomls() {
  local task="{}"
  local base_prev=
  local type name func_name base body
  while read -r type name func_name base body
  do
    if test "$base" != "$base_prev"
    then
      if jq -n --argjson input "$task" --exit-status \
        '$input | length > 0' >/dev/null
      then
        printf "%s" "$task" | yj -jt >"gen-$base_prev.toml"
      fi
      task="{}"
    fi
    case "$type" in
      (task|subcmd)
        task="$(
          jq -n --argjson input "$task" \
            --arg name "$name" \
            --arg desc "$body" \
            '$input | .[$name]["description"] = $desc'
        )"
        task="$(
          jq -n --argjson input "$task" \
            --arg name "$name" \
            --arg script "$(gen_script "$func_name")" \
            '$input | .[$name]["run"] = $script')"
        ;;
      (mise)
        local mise_header="$(printf "%s" "$body" | yj -tj)"
        task="$(
          jq -n --argjson input "$task" \
            --arg name "$name" \
            --argjson mise_header "$mise_header" \
            '$input | .[$name] += $mise_header')"
        ;;
      (nop)
        ;;
      (*)
        exit 1
    esac
    base_prev="$base"
  done
}

if ! test -d "$MISE_PROJECT_ROOT"/"$mise_sh_tasks_dir"
then
  echo "Mise shell tasks directory \"$MISE_PROJECT_ROOT/$mise_sh_tasks_dir\" does not exist." >&2
  exit 1
fi
cd "$MISE_PROJECT_ROOT"/"$mise_sh_tasks_dir"
rm -f gen-*.toml
extract_task_info *.lib.sh | generate_task_tomls
'''
